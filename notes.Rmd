---
title: "Mixing Model Failings in Stan"
author: "Kyle Chezik"
date: "2/27/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

I'm attempting to decompose temperature data into two parts; water and not water (i.e., air). Given the immense task of labeling these data for traditional supervised methods, I'm attempting to devise a unsupervised routine. My first intuition is to breakdown the data into numerous descriptions. For instance, the biggest indicator temperatures have switched from water to air is a large increase in variance. Thus, I've conducted a maximal overlap discrete wavelet transform (`MODWT`) using the `wmtsa` library, thereby fitting a frequency to the data at various time scales which provides coefficients estimates describing the harmonics. Below you can see the raw data and the `1d` time step of wavelet coeffients (i.e., `wavD`). I've also calculated temperature differences between time steps (`Dif`) and a 5 time point rolling average of the standard deviation (`Tsd`).

```{r}
library(tidyverse)
test = read_rds(path = "./Data/test.rds")

p1 = ggplot(data = test, aes(DateTime, Temperature)) + geom_point()
p2 = ggplot(data = test, aes(DateTime, wavD)) + geom_point()
p3 = ggplot(data = test, aes(DateTime, Dif)) + geom_point()
p4 = ggplot(data = test, aes(DateTime, Tsd)) + geom_point()
gridExtra::grid.arrange(p1, p2, p3, p4)
```

Using these descriptions of change in the data, I've fit several Markov Switching Models using the `MSwM` library. The package allows for quick estimation of switches in variance over time by fitting a simple `glm`. It also outputs the probability each observation is in each regime. Thus each model is simply parameterized to have two regimes, no slope parameter and the intercept is assumed to be zero for `wavD` and `Dif`. I then took the probability estimates associated with the high variance state and summed then across the models to get a joint probability where aggreements enhanced our certainty of regime changes.

```{r}
library(viridis);library(attenPlot)
# Here is the "best fit" via AIC.
T_MSwM = MSwM::msmFit(object = as.formula("Temperature ~ 0"),
                      data = test, k=2, p=1, sw=c(F,T))
# Here I fit them seperately.
wavMSwM=MSwM::msmFit(object = as.formula("wavD ~ 0"), data = test,
                      k=2, p=1, sw=c(F,T), control=list(parallel=F))

DifMSwM=MSwM::msmFit(object = as.formula("Dif ~ 0"), data = test,
                      k=2, p=1, sw=c(F,T), control=list(parallel=F))

TsdMSwM=MSwM::msmFit(object = as.formula("Tsd ~ 0"), data = test,
                      k=2, p=1, sw=c(F,T), control=list(parallel=F))

lDif=MSwM::msmFit(object = as.formula("ldiff~1"), data = d_test,
                  k = 2, p=1, sw=c(T,T,T), control=list(parallel=F))

airD = which(DifMSwM@std == max(DifMSwM@std))
airW = which(wavMSwM@std == max(wavMSwM@std))
airS = which(TsdMSwM@std == max(TsdMSwM@std))
air = which(T_MSwM@std == max(T_MSwM@std))
airDL = which(lDif@std == max(lDif@std))

test = bind_cols(test, data.frame(air_w = wavMSwM@Fit@smoProb[,airW],
                                  air_d = DifMSwM@Fit@smoProb[,airD],
                                  air_s = TsdMSwM@Fit@smoProb[,airS],
                                  air_a = T_MSwM@Fit@smoProb[,air],
                                  air_dl = lDif@Fit@smoProb[,airDL]))

p1 = ggplot(test, aes(DateTime, Temperature, color = air_w)) + geom_point() + scale_color_viridis() + 
  theme(legend.position = "none") + ggtitle("wavelet")
p2 = ggplot(test, aes(DateTime, Temperature, color = air_d)) + geom_point() + scale_color_viridis() + 
  theme(legend.position = "none") + ggtitle("difference")
p3 = ggplot(test, aes(DateTime, Temperature, color = air_s)) + geom_point() + scale_color_viridis() + 
  theme(legend.position = "none") + ggtitle("standard deviation")
p4 = ggplot(test, aes(DateTime, Temperature, color = air_a)) + geom_point() + scale_color_viridis() + 
  theme(legend.position = "none") + ggtitle("temperature")
  theme(legend.position = "none") + ggtitle("composite")
p5 = ggplot(test, aes(DateTime, Temperature, color = air_dl)) + geom_point() + scale_color_viridis() + 
  theme(legend.position = "none") + ggtitle("log difference")
gridExtra::grid.arrange(p1, p2, p3, p4, p5, layout_matrix = matrix(data = c(1,4,1,4,2,4,2,5,3,5,3,5), nrow = 2, ncol = 6))
```

These Markov Switching models made me wonder if I could improve on these results by buiding the model in Stan and adding seasonality to the variance structure. It would also be nice to build the model into a heirarchical structure so information on variance regimes could be shared across sites.

I found a blog by Jim Savage on finite mixture models in Stan (url=https://modernstatisticalworkflow.blogspot.com/2016/10/finite-mixture-models-in-stan.html). It gave a nice tutorial on fitting a model that tries to group data by density distribution. Using file `MSwM2.stan` I built the same model for one of my response variables (`wavD`). I also followed chapter 13 of the Stan Reference manual on Finite Mixtures which I largely copied the model on page ~194. 

```{r}
library(rstan)
options(mc.cores = parallel::detectCores())

obs = list(K = 2, N = nrow(test), y = test$wavD)
mod = stan(file = "./R/MSwM2.stan", data = obs,
            control = list(adapt_delta = 0.85,
                           max_treedepth = 12))

#Check Model
print(mod)
traceplot(mod)
stan_dens(mod)
```

This model converges but it's much slower than the previous `MSwM` approach and doesn't include an AR1 structure nor does it return a vector of probability estimates for each observation. It appears I'm struggling in this model with label switching or simply the data share too much information to differentiate between the two states of variability, probably because they share the same mean. This model is a bit worthless in its current state as it could never separate data near the mean. We should be able to say data far from the mean are likely in one group over the other but that's about it. Furthermore, the Rhats are big and the n_effs are small, nor do these results aggree with the prior `MSwM` approach. This model was a good starting place for me in Stan and maybe with more information, Stan can do a better job of separating out the two regimes.

As a second attempt I used Jim's subsequent blog on Finite Mixture Models with time-varying probabilites (http://modernstatisticalworkflow.blogspot.com/2016/10/) to see if adding a time component helps differentiate between the model states (file `MSwM.stan`). I also referenced section 13.5 in the Stan Ref. book, where unfortunately it states there is currently no way to vectorize mixture models at the observation level, which I take to mean it's going to be a slow model to fit. On the plus side, the model estimates probabilities at the observation level and takes into account some degree of temporal information such as the previous time steps observed value and the previous time steps probability of being on one regime or the other. After running this model a few times and having problems getting aggreement in all my chains, I found this helpful guide on identifying mixture models (http://mc-stan.org/users/documentation/case-studies/identifying_mixture_models.html). It suggests making one parameter `ordered` and/or giving parameters that are difficult to distinguish non-exchangeable priors. I tried both methods but they seem not to improve the model fit or fit times. I have gotten lucky once where the fits looked pretty good and the model was in good aggreement with the `MSwM` method but I forgot to save those initial values. I was encouraged by this one success because the fit capture the differences in temperatuer data very well. Better than prior attempts using `MSwM`.

```{r}
library(rstan)
options(mc.cores = parallel::detectCores())

obs = list(N = nrow(test), y = test$wavD)
mod_obs = stan(file = "./R/MSwM.stan", data = obs,
               warmup = 1000, chains = 4,
               control = list(adapt_delta = 0.85,
                              max_treedepth = 12))

#Check Model
print(mod_obs)
traceplot(mod_obs, pars = "sigma")
stan_dens(mod_obs)

est <- mod_obs %>%
  as.data.frame() %>%
  select(contains("mu")) %>%
  reshape2::melt() %>%
  group_by(variable) %>%
  summarise(lower = quantile(value, 0.95),
            median = median(value),
            upper = quantile(value, 0.05)) %>%
  mutate(date = test$DateTime,
         ac = test$Temperature)

 plot1 = ggplot(est, aes(x = date)) +
  geom_ribbon(aes(ymin = arm::invlogit(lower), ymax = arm::invlogit(upper)), fill= "orange", alpha = 0.4) +
  geom_line(aes(y = arm::invlogit(median))) +
  ggthemes::theme_economist() +
  xlab("Date") +
  ylab("Probability of air temperature")

plot2 = ggplot(est, aes(x = date, y = ac)) +
  geom_line() +
  ggthemes::theme_economist() +
  xlab("Date") +
  ylab("Temperature")

Bays_wavP = ggplot(est, aes(date, ac, color = 1-arm::invlogit(median))) + geom_point() + scale_color_viridis() + labs(x ="DateTime", y = "Temperature", col = "air")
gridExtra::grid.arrange(p4,plot1,Bays_wavP,plot2)
```

It seems to me that we are drawing from the wrong distribution in this model. We need a distribution that is continuous and bound between 0 and 1 such as the `beta`. Looking at moment matching in "Bayesian Models A Statistical Primer for Ecologist", I have attempted to impliment a beta distribution version of the previous Time-varying Mixture Model in file `MSwM3.stan`. It currently does not work as I'm not sure how to formulate what I want in Stan language.











#New Variables

#Could simple use autocorrelation values instead of or in addition to difference values.


#Wavelet improvement.

#Retain the larger seasonal component and look for large deviations from the expectation. It may reveal the buried logger special case.


#Markov Switching Model Improvement

#Figure out how to give the MSwM a variance structure that changes over the season rather than simply switching between two static states. More verbosely we want two variance models that grow and decline on a sinusoidal curve resembling the season. In this way we can detect when we are in a different state or just when we are in a more variable part of the season but in a single state.

#It would also be great to compare these probabilities across sites and downweight or upweight depending on agreement.


## Special cases that need consideration. ##

#We need to test this on data where no air temperature was measured.
#Seed 425 may be when the logger is buried (10602068sept0615.csv).
